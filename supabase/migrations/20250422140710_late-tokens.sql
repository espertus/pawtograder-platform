drop view if exists "public"."autograder_regression_test_by_grader";

drop view if exists "public"."submissions_agg";

drop view if exists "public"."submissions_with_grades_for_assignment";

create table "public"."assignment_due_date_exceptions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint,
    "assignment_id" bigint not null,
    "student_id" uuid,
    "assignment_group_id" bigint,
    "creator_id" uuid not null,
    "note" text,
    "hours" integer not null,
    "tokens_consumed" integer not null default 0
);


alter table "public"."assignment_due_date_exceptions" enable row level security;

create table "public"."repository_check_runs" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint not null,
    "repository_id" bigint not null,
    "check_run_id" bigint not null,
    "status" jsonb not null,
    "sha" text not null,
    "commit_message" text not null,
    "profile_id" uuid,
    "assignment_group_id" bigint,
    "triggered_by" uuid
);


alter table "public"."repository_check_runs" enable row level security;

alter table "public"."assignments" drop column "allow_late";

alter table "public"."assignments" drop column "latest_due_date";

alter table "public"."assignments" add column "max_late_tokens" integer not null default 0;

alter table "public"."audit" alter column "new" drop not null;

alter table "public"."autograder" add column "max_submissions_count" integer;

alter table "public"."autograder" add column "max_submissions_period_secs" integer;

alter table "public"."classes" add column "late_tokens_per_student" integer not null default 0;

alter table "public"."submissions" drop column "check_run_id";

alter table "public"."submissions" add column "repository_check_run_id" bigint;

alter table "public"."submissions" add column "repository_id" bigint;

CREATE UNIQUE INDEX assignment_late_exception_pkey ON public.assignment_due_date_exceptions USING btree (id);

CREATE INDEX repositories_repository_idx ON public.repositories USING hash (repository);

CREATE UNIQUE INDEX repository_check_run_pkey ON public.repository_check_runs USING btree (id);

CREATE INDEX repository_check_runs_check_run_id_idx ON public.repository_check_runs USING btree (check_run_id);

CREATE INDEX repository_check_runs_repository_id_class_id_idx ON public.repository_check_runs USING btree (repository_id, class_id);

CREATE INDEX repository_check_runs_repository_id_sha_idx ON public.repository_check_runs USING btree (repository_id, sha);

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_pkey" PRIMARY KEY using index "assignment_late_exception_pkey";

alter table "public"."repository_check_runs" add constraint "repository_check_run_pkey" PRIMARY KEY using index "repository_check_run_pkey";

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_assignment_group_id_fkey" FOREIGN KEY (assignment_group_id) REFERENCES assignment_groups(id) not valid;

alter table "public"."assignment_due_date_exceptions" validate constraint "assignment_late_exception_assignment_group_id_fkey";

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES assignments(id) not valid;

alter table "public"."assignment_due_date_exceptions" validate constraint "assignment_late_exception_assignment_id_fkey";

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."assignment_due_date_exceptions" validate constraint "assignment_late_exception_class_id_fkey";

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_instructor_id_fkey" FOREIGN KEY (creator_id) REFERENCES profiles(id) not valid;

alter table "public"."assignment_due_date_exceptions" validate constraint "assignment_late_exception_instructor_id_fkey";

alter table "public"."assignment_due_date_exceptions" add constraint "assignment_late_exception_student_id_fkey" FOREIGN KEY (student_id) REFERENCES profiles(id) not valid;

alter table "public"."assignment_due_date_exceptions" validate constraint "assignment_late_exception_student_id_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_run_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_run_class_id_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_run_repository_id_fkey" FOREIGN KEY (repository_id) REFERENCES repositories(id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_run_repository_id_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_runs_assignment_group_id_fkey" FOREIGN KEY (assignment_group_id) REFERENCES assignment_groups(id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_runs_assignment_group_id_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_runs_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_runs_profile_id_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_runs_triggered_by_fkey" FOREIGN KEY (triggered_by) REFERENCES profiles(id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_runs_triggered_by_fkey";

alter table "public"."repository_check_runs" add constraint "repository_check_runs_triggered_by_fkey1" FOREIGN KEY (triggered_by) REFERENCES user_roles(private_profile_id) not valid;

alter table "public"."repository_check_runs" validate constraint "repository_check_runs_triggered_by_fkey1";

alter table "public"."submissions" add constraint "submissions_repository_check_run_id_fkey" FOREIGN KEY (repository_check_run_id) REFERENCES repository_check_runs(id) not valid;

alter table "public"."submissions" validate constraint "submissions_repository_check_run_id_fkey";

alter table "public"."submissions" add constraint "submissions_repository_id_fkey" FOREIGN KEY (repository_id) REFERENCES repositories(id) not valid;

alter table "public"."submissions" validate constraint "submissions_repository_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.audit_insert_and_update_and_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
    declare
      remote_ip text;
BEGIN
SELECT split_part(
  current_setting('request.headers', true)::json->>'x-forwarded-for',
  ',', 1) into remote_ip;
   CASE TG_OP
   WHEN 'UPDATE' THEN
      INSERT INTO audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      row_to_json(OLD.*),
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   WHEN 'INSERT' THEN
      INSERT INTO audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      NULL,
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   WHEN 'DELETE' THEN
      INSERT INTO audit (class_id,user_id,"table",old,new, ip_addr) values
      (OLD.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      row_to_json(OLD.*),
      NULL,
      remote_ip
      );
      RETURN NULL;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_to_create_own_due_date_extension(_student_id uuid, _assignment_group_id bigint, _assignment_id bigint, _class_id bigint, _creator_id uuid, _hours_to_extend integer, _tokens_consumed integer)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  tokens_used int;
  tokens_remaining int;
  tokens_needed int;
  max_tokens_for_assignment int;
  private_profile_id uuid;
begin

  -- Validate that the declared number of tokens consumed is correct
  tokens_needed := ceil(_hours_to_extend/24);
  if tokens_needed != _tokens_consumed then
    return false;
  end if;

  select public.user_roles.private_profile_id from public.user_roles where user_id = auth.uid() and class_id = _class_id into private_profile_id;
  -- Make sure student is in the class and the creator of the extension
  if private_profile_id is null or private_profile_id != _creator_id then
    return false;
  end if;

  select late_tokens_per_student from public.classes where id = _class_id into tokens_remaining;

  -- Make sure that the student is in the assignment group or matches the student_id
  if _assignment_group_id is not null then
    if not exists (select 1 from public.assignment_groups_members where assignment_group_id = _assignment_group_id and profile_id = private_profile_id) then
      return false;
    end if;
    select sum(tokens_consumed) from public.assignment_due_date_exceptions where assignment_group_id = _assignment_group_id and assignment_id = _assignment_id into tokens_used;
  else
    if private_profile_id != _student_id then
      return false;
    end if;
      select sum(tokens_consumed) from public.assignment_due_date_exceptions where student_id = _student_id and assignment_id = _assignment_id into tokens_used;
  end if;

  tokens_used = tokens_used + tokens_needed;
  if tokens_used > tokens_remaining then
    return false;
  end if;

  select max_late_tokens from public.assignments where id=_assignment_id into max_tokens_for_assignment;

  if tokens_used > max_tokens_for_assignment then
    return false;
  end if;


  return true;
end;
$function$
;

create or replace view "public"."autograder_regression_test_by_grader" as  SELECT a.grader_repo,
    t.repository,
    s.sha,
    t.id,
    s.class_id
   FROM (((autograder_regression_test t
     JOIN autograder a ON ((a.id = t.autograder_id)))
     JOIN submissions s ON ((s.repository = t.repository)))
     JOIN grader_results g ON ((g.submission_id = s.id)))
  GROUP BY s.sha, a.grader_repo, t.repository, s.created_at, t.id, s.class_id
 HAVING (s.created_at = max(s.created_at));


create or replace view "public"."submissions_agg" as  SELECT c.profile_id,
    p.name,
    p.sortable_name,
    p.avatar_url,
    groups.name AS groupname,
    c.submissioncount,
    c.latestsubmissionid,
    s.id,
    s.created_at,
    s.assignment_id,
    s.profile_id AS user_id,
    s.released,
    s.sha,
    s.repository,
    s.run_attempt,
    s.run_number,
    g.score,
    g.ret_code,
    g.execution_time
   FROM ((((( SELECT count(submissions.id) AS submissioncount,
            max(submissions.id) AS latestsubmissionid,
            r.private_profile_id AS profile_id
           FROM ((user_roles r
             LEFT JOIN assignment_groups_members m ON ((m.profile_id = r.private_profile_id)))
             LEFT JOIN submissions ON (((submissions.profile_id = r.private_profile_id) OR (submissions.assignment_group_id = m.assignment_group_id))))
          GROUP BY submissions.assignment_id, r.private_profile_id) c
     LEFT JOIN submissions s ON ((s.id = c.latestsubmissionid)))
     LEFT JOIN assignment_groups groups ON ((groups.id = s.assignment_group_id)))
     LEFT JOIN grader_results g ON ((g.submission_id = s.id)))
     JOIN profiles p ON ((p.id = c.profile_id)));


create or replace view "public"."submissions_with_grades_for_assignment" as  SELECT activesubmissionsbystudent.id,
    activesubmissionsbystudent.class_id,
    activesubmissionsbystudent.assignment_id,
    p.name,
    p.sortable_name,
    s.id AS activesubmissionid,
    s.created_at,
    s.released,
    s.repository,
    s.sha,
    ar.score AS autograder_score,
    rev.grader,
    rev.meta_grader,
    rev.total_score,
    rev.tweak,
    rev.completed_by,
    rev.completed_at,
    rev.checked_at,
    rev.checked_by,
    graderprofile.name AS assignedgradername,
    metagraderprofile.name AS assignedmetagradername,
    completerprofile.name AS gradername,
    checkgraderprofile.name AS checkername,
    ag.name AS groupname,
    activesubmissionsbystudent.tokens_consumed,
    activesubmissionsbystudent.hours,
    activesubmissionsbystudent.due_date,
    (activesubmissionsbystudent.due_date + ('01:00:00'::interval * (activesubmissionsbystudent.hours)::double precision)) AS late_due_date
   FROM (((((((((( SELECT r.id,
                CASE
                    WHEN (isub.id IS NULL) THEN gsub.id
                    ELSE isub.id
                END AS sub_id,
            r.private_profile_id,
            r.class_id,
            a.id AS assignment_id,
            agm.assignment_group_id AS assignmentgroupid,
            lt.tokens_consumed,
            lt.hours,
            a.due_date
           FROM (((((user_roles r
             JOIN assignments a ON ((a.class_id = r.class_id)))
             LEFT JOIN submissions isub ON (((isub.profile_id = r.private_profile_id) AND (isub.is_active = true) AND (isub.assignment_id = a.id))))
             LEFT JOIN assignment_groups_members agm ON (((agm.profile_id = r.private_profile_id) AND (agm.assignment_id = a.id))))
             LEFT JOIN ( SELECT sum(assignment_due_date_exceptions.tokens_consumed) AS tokens_consumed,
                    sum(assignment_due_date_exceptions.hours) AS hours,
                    assignment_due_date_exceptions.student_id,
                    assignment_due_date_exceptions.assignment_group_id
                   FROM assignment_due_date_exceptions
                  GROUP BY assignment_due_date_exceptions.student_id, assignment_due_date_exceptions.assignment_group_id) lt ON ((((agm.assignment_group_id IS NULL) AND (lt.student_id = r.private_profile_id)) OR ((agm.assignment_group_id IS NOT NULL) AND (lt.assignment_group_id = agm.assignment_group_id)))))
             LEFT JOIN submissions gsub ON (((gsub.assignment_group_id = agm.id) AND (gsub.is_active = true) AND (gsub.assignment_id = a.id))))
          WHERE (r.role = 'student'::app_role)) activesubmissionsbystudent
     JOIN profiles p ON ((p.id = activesubmissionsbystudent.private_profile_id)))
     LEFT JOIN submissions s ON ((s.id = activesubmissionsbystudent.sub_id)))
     LEFT JOIN submission_reviews rev ON ((rev.id = s.grading_review_id)))
     LEFT JOIN grader_results ar ON ((ar.submission_id = s.id)))
     LEFT JOIN assignment_groups ag ON ((ag.id = activesubmissionsbystudent.assignmentgroupid)))
     LEFT JOIN profiles completerprofile ON ((completerprofile.id = rev.completed_by)))
     LEFT JOIN profiles graderprofile ON ((graderprofile.id = rev.grader)))
     LEFT JOIN profiles metagraderprofile ON ((metagraderprofile.id = rev.meta_grader)))
     LEFT JOIN profiles checkgraderprofile ON ((checkgraderprofile.id = rev.checked_by)));


grant delete on table "public"."assignment_due_date_exceptions" to "anon";

grant insert on table "public"."assignment_due_date_exceptions" to "anon";

grant references on table "public"."assignment_due_date_exceptions" to "anon";

grant select on table "public"."assignment_due_date_exceptions" to "anon";

grant trigger on table "public"."assignment_due_date_exceptions" to "anon";

grant truncate on table "public"."assignment_due_date_exceptions" to "anon";

grant update on table "public"."assignment_due_date_exceptions" to "anon";

grant delete on table "public"."assignment_due_date_exceptions" to "authenticated";

grant insert on table "public"."assignment_due_date_exceptions" to "authenticated";

grant references on table "public"."assignment_due_date_exceptions" to "authenticated";

grant select on table "public"."assignment_due_date_exceptions" to "authenticated";

grant trigger on table "public"."assignment_due_date_exceptions" to "authenticated";

grant truncate on table "public"."assignment_due_date_exceptions" to "authenticated";

grant update on table "public"."assignment_due_date_exceptions" to "authenticated";

grant delete on table "public"."assignment_due_date_exceptions" to "service_role";

grant insert on table "public"."assignment_due_date_exceptions" to "service_role";

grant references on table "public"."assignment_due_date_exceptions" to "service_role";

grant select on table "public"."assignment_due_date_exceptions" to "service_role";

grant trigger on table "public"."assignment_due_date_exceptions" to "service_role";

grant truncate on table "public"."assignment_due_date_exceptions" to "service_role";

grant update on table "public"."assignment_due_date_exceptions" to "service_role";

grant delete on table "public"."repository_check_runs" to "anon";

grant insert on table "public"."repository_check_runs" to "anon";

grant references on table "public"."repository_check_runs" to "anon";

grant select on table "public"."repository_check_runs" to "anon";

grant trigger on table "public"."repository_check_runs" to "anon";

grant truncate on table "public"."repository_check_runs" to "anon";

grant update on table "public"."repository_check_runs" to "anon";

grant delete on table "public"."repository_check_runs" to "authenticated";

grant insert on table "public"."repository_check_runs" to "authenticated";

grant references on table "public"."repository_check_runs" to "authenticated";

grant select on table "public"."repository_check_runs" to "authenticated";

grant trigger on table "public"."repository_check_runs" to "authenticated";

grant truncate on table "public"."repository_check_runs" to "authenticated";

grant update on table "public"."repository_check_runs" to "authenticated";

grant delete on table "public"."repository_check_runs" to "service_role";

grant insert on table "public"."repository_check_runs" to "service_role";

grant references on table "public"."repository_check_runs" to "service_role";

grant select on table "public"."repository_check_runs" to "service_role";

grant trigger on table "public"."repository_check_runs" to "service_role";

grant truncate on table "public"."repository_check_runs" to "service_role";

grant update on table "public"."repository_check_runs" to "service_role";

create policy "Graders and instructors insert"
on "public"."assignment_due_date_exceptions"
as permissive
for insert
to public
with check (((authorizeforprofile(creator_id) AND authorizeforclassgrader(class_id)) OR authorize_to_create_own_due_date_extension(student_id, assignment_group_id, assignment_id, class_id, creator_id, hours, tokens_consumed)));


create policy "Instructors all, students own"
on "public"."assignment_due_date_exceptions"
as permissive
for select
to public
using ((authorizeforclassgrader(class_id) OR authorizeforprofile(student_id) OR authorizeforassignmentgroup(assignment_group_id)));


create policy "graders and instructors delete"
on "public"."assignment_due_date_exceptions"
as permissive
for delete
to public
using (authorizeforclassgrader(class_id));


create policy "graders/instructors"
on "public"."assignment_due_date_exceptions"
as permissive
for update
to public
using ((authorizeforprofile(creator_id) AND authorizeforclass(class_id)));


create policy "instructors all, students own"
on "public"."repository_check_runs"
as permissive
for select
to public
using ((authorizeforclassgrader(class_id) OR authorizeforprofile(profile_id) OR authorizeforassignmentgroup(assignment_group_id)));


CREATE TRIGGER audit_assignment_due_date_exceptions_insert_update AFTER INSERT OR DELETE OR UPDATE ON public.assignment_due_date_exceptions FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();

CREATE TRIGGER audit_rubric_checks_insert_update AFTER INSERT OR DELETE OR UPDATE ON public.rubric_checks FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();

CREATE TRIGGER audit_rubric_criteria_insert_update AFTER INSERT OR DELETE OR UPDATE ON public.rubric_criteria FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();

CREATE TRIGGER audit_rubric_parts_insert_update AFTER INSERT OR DELETE OR UPDATE ON public.rubric_parts FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();


