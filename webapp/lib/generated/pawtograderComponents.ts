/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import * as reactQuery from '@tanstack/react-query';
import { usePawtograderContext, PawtograderContext } from './pawtograderContext';
import type * as Fetcher from './pawtograderFetcher';
import { pawtograderFetch } from './pawtograderFetcher';
import type * as Schemas from './pawtograderSchemas';

export type CreateGitHubReposForStudentError = Fetcher.ErrorWrapper<undefined>;

export type CreateGitHubReposForStudentResponse = {
  message: string;
  is_ok: boolean;
};

export type CreateGitHubReposForStudentVariables = PawtograderContext['fetcherOptions'];

export const fetchCreateGitHubReposForStudent = (
  variables: CreateGitHubReposForStudentVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    CreateGitHubReposForStudentResponse,
    CreateGitHubReposForStudentError,
    undefined,
    {},
    {},
    {}
  >({
    url: '/api/autograder/create-github-repos-for-student',
    method: 'post',
    ...variables,
    signal,
  });

export const useCreateGitHubReposForStudent = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateGitHubReposForStudentResponse,
      CreateGitHubReposForStudentError,
      CreateGitHubReposForStudentVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    CreateGitHubReposForStudentResponse,
    CreateGitHubReposForStudentError,
    CreateGitHubReposForStudentVariables
  >({
    mutationFn: (variables: CreateGitHubReposForStudentVariables) =>
      fetchCreateGitHubReposForStudent({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RetrieveAutograderRegressionTestsHeaders = {
  Authorization: string;
};

export type RetrieveAutograderRegressionTestsError = Fetcher.ErrorWrapper<undefined>;

export type RetrieveAutograderRegressionTestsResponse = {
  configs: {
    /**
     * @format double
     */
    id: number;
  }[];
};

export type RetrieveAutograderRegressionTestsVariables = {
  headers: RetrieveAutograderRegressionTestsHeaders;
} & PawtograderContext['fetcherOptions'];

export const fetchRetrieveAutograderRegressionTests = (
  variables: RetrieveAutograderRegressionTestsVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    RetrieveAutograderRegressionTestsResponse,
    RetrieveAutograderRegressionTestsError,
    undefined,
    RetrieveAutograderRegressionTestsHeaders,
    {},
    {}
  >({ url: '/api/autograder/regression-tests', method: 'get', ...variables, signal });

export const useRetrieveAutograderRegressionTests = <
  TData = RetrieveAutograderRegressionTestsResponse,
>(
  variables: RetrieveAutograderRegressionTestsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RetrieveAutograderRegressionTestsResponse,
      RetrieveAutograderRegressionTestsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<
    RetrieveAutograderRegressionTestsResponse,
    RetrieveAutograderRegressionTestsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/autograder/regression-tests',
      operationId: 'retrieveAutograderRegressionTests',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchRetrieveAutograderRegressionTests({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateSubmissionHeaders = {
  Authorization: string;
};

export type CreateSubmissionError = Fetcher.ErrorWrapper<undefined>;

export type CreateSubmissionVariables = {
  headers: CreateSubmissionHeaders;
} & PawtograderContext['fetcherOptions'];

export const fetchCreateSubmission = (variables: CreateSubmissionVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    Schemas.SubmissionResponse,
    CreateSubmissionError,
    undefined,
    CreateSubmissionHeaders,
    {},
    {}
  >({ url: '/api/autograder/submission', method: 'post', ...variables, signal });

export const useCreateSubmission = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SubmissionResponse,
      CreateSubmissionError,
      CreateSubmissionVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    Schemas.SubmissionResponse,
    CreateSubmissionError,
    CreateSubmissionVariables
  >({
    mutationFn: (variables: CreateSubmissionVariables) =>
      fetchCreateSubmission({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CreateRegressionTestRunPathParams = {
  /**
   * @format double
   */
  regressionTestId: number;
};

export type CreateRegressionTestRunHeaders = {
  Authorization: string;
};

export type CreateRegressionTestRunError = Fetcher.ErrorWrapper<undefined>;

export type CreateRegressionTestRunVariables = {
  headers: CreateRegressionTestRunHeaders;
  pathParams: CreateRegressionTestRunPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchCreateRegressionTestRun = (
  variables: CreateRegressionTestRunVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    Schemas.RegressionTestRunResponse,
    CreateRegressionTestRunError,
    undefined,
    CreateRegressionTestRunHeaders,
    {},
    CreateRegressionTestRunPathParams
  >({
    url: '/api/autograder/regression-test-run/{regressionTestId}',
    method: 'post',
    ...variables,
    signal,
  });

export const useCreateRegressionTestRun = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RegressionTestRunResponse,
      CreateRegressionTestRunError,
      CreateRegressionTestRunVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    Schemas.RegressionTestRunResponse,
    CreateRegressionTestRunError,
    CreateRegressionTestRunVariables
  >({
    mutationFn: (variables: CreateRegressionTestRunVariables) =>
      fetchCreateRegressionTestRun({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SubmitFeedbackQueryParams = {
  /**
   * @format double
   */
  autograder_regression_test_id?: number;
};

export type SubmitFeedbackHeaders = {
  Authorization: string;
};

export type SubmitFeedbackError = Fetcher.ErrorWrapper<undefined>;

export type SubmitFeedbackVariables = {
  body: Schemas.GradingScriptResult;
  headers: SubmitFeedbackHeaders;
  queryParams?: SubmitFeedbackQueryParams;
} & PawtograderContext['fetcherOptions'];

export const fetchSubmitFeedback = (variables: SubmitFeedbackVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    Schemas.GradeResponse,
    SubmitFeedbackError,
    Schemas.GradingScriptResult,
    SubmitFeedbackHeaders,
    SubmitFeedbackQueryParams,
    {}
  >({ url: '/api/autograder/submission/feedback', method: 'post', ...variables, signal });

export const useSubmitFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.GradeResponse,
      SubmitFeedbackError,
      SubmitFeedbackVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    Schemas.GradeResponse,
    SubmitFeedbackError,
    SubmitFeedbackVariables
  >({
    mutationFn: (variables: SubmitFeedbackVariables) =>
      fetchSubmitFeedback({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCanvasCoursesError = Fetcher.ErrorWrapper<undefined>;

export type GetCanvasCoursesResponse = Schemas.Course[];

export type GetCanvasCoursesVariables = PawtograderContext['fetcherOptions'];

export const fetchGetCanvasCourses = (variables: GetCanvasCoursesVariables, signal?: AbortSignal) =>
  pawtograderFetch<GetCanvasCoursesResponse, GetCanvasCoursesError, undefined, {}, {}, {}>({
    url: '/api/admin/canvas/courses',
    method: 'get',
    ...variables,
    signal,
  });

export const useGetCanvasCourses = <TData = GetCanvasCoursesResponse,>(
  variables: GetCanvasCoursesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCanvasCoursesResponse, GetCanvasCoursesError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<GetCanvasCoursesResponse, GetCanvasCoursesError, TData>({
    queryKey: queryKeyFn({
      path: '/api/admin/canvas/courses',
      operationId: 'getCanvasCourses',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetCanvasCourses({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCanvasCoursePathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type GetCanvasCourseError = Fetcher.ErrorWrapper<undefined>;

export type GetCanvasCourseVariables = {
  pathParams: GetCanvasCoursePathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchGetCanvasCourse = (variables: GetCanvasCourseVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    Schemas.Course,
    GetCanvasCourseError,
    undefined,
    {},
    {},
    GetCanvasCoursePathParams
  >({ url: '/api/admin/canvas/courses/{courseId}', method: 'get', ...variables, signal });

export const useGetCanvasCourse = <TData = Schemas.Course,>(
  variables: GetCanvasCourseVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Course, GetCanvasCourseError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<Schemas.Course, GetCanvasCourseError, TData>({
    queryKey: queryKeyFn({
      path: '/api/admin/canvas/courses/{courseId}',
      operationId: 'getCanvasCourse',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetCanvasCourse({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateAssignmentRepositoriesPathParams = {
  /**
   * @format double
   */
  courseId: number;
  /**
   * @format double
   */
  assignmentId: number;
};

export type CreateAssignmentRepositoriesError = Fetcher.ErrorWrapper<undefined>;

export type CreateAssignmentRepositoriesVariables = {
  pathParams: CreateAssignmentRepositoriesPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchCreateAssignmentRepositories = (
  variables: CreateAssignmentRepositoriesVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    undefined,
    CreateAssignmentRepositoriesError,
    undefined,
    {},
    {},
    CreateAssignmentRepositoriesPathParams
  >({
    url: '/api/instructor/{courseId}/assignment/{assignmentId}/repositories',
    method: 'post',
    ...variables,
    signal,
  });

export const useCreateAssignmentRepositories = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      CreateAssignmentRepositoriesError,
      CreateAssignmentRepositoriesVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    undefined,
    CreateAssignmentRepositoriesError,
    CreateAssignmentRepositoriesVariables
  >({
    mutationFn: (variables: CreateAssignmentRepositoriesVariables) =>
      fetchCreateAssignmentRepositories({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AddEnrollmentPathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type AddEnrollmentError = Fetcher.ErrorWrapper<undefined>;

export type AddEnrollmentRequestBody = {
  role: 'admin' | 'instructor' | 'grader' | 'student';
  name: string;
  email: string;
};

export type AddEnrollmentVariables = {
  body: AddEnrollmentRequestBody;
  pathParams: AddEnrollmentPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchAddEnrollment = (variables: AddEnrollmentVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    undefined,
    AddEnrollmentError,
    AddEnrollmentRequestBody,
    {},
    {},
    AddEnrollmentPathParams
  >({ url: '/api/instructor/{courseId}/enrollments', method: 'post', ...variables, signal });

export const useAddEnrollment = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, AddEnrollmentError, AddEnrollmentVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<undefined, AddEnrollmentError, AddEnrollmentVariables>({
    mutationFn: (variables: AddEnrollmentVariables) =>
      fetchAddEnrollment({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type SyncEnrollmentsPathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type SyncEnrollmentsError = Fetcher.ErrorWrapper<undefined>;

export type SyncEnrollmentsVariables = {
  pathParams: SyncEnrollmentsPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchSyncEnrollments = (variables: SyncEnrollmentsVariables, signal?: AbortSignal) =>
  pawtograderFetch<undefined, SyncEnrollmentsError, undefined, {}, {}, SyncEnrollmentsPathParams>({
    url: '/api/instructor/{courseId}/canvas/enrollments',
    method: 'post',
    ...variables,
    signal,
  });

export const useSyncEnrollments = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, SyncEnrollmentsError, SyncEnrollmentsVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<undefined, SyncEnrollmentsError, SyncEnrollmentsVariables>({
    mutationFn: (variables: SyncEnrollmentsVariables) =>
      fetchSyncEnrollments({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetTemplateReposPathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type GetTemplateReposError = Fetcher.ErrorWrapper<undefined>;

export type GetTemplateReposResponse = {
  security_and_analysis?: {
    secret_scanning_ai_detection?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning_non_provider_patterns?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning_push_protection?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning?: {
      status?: 'enabled' | 'disabled';
    };
    dependabot_security_updates?: {
      status?: 'enabled' | 'disabled';
    };
    advanced_security?: {
      status?: 'enabled' | 'disabled';
    };
  };
  web_commit_signoff_required?: boolean;
  allow_forking?: boolean;
  /**
   * @format double
   */
  watchers?: number;
  /**
   * @format double
   */
  open_issues?: number;
  /**
   * @format double
   */
  forks?: number;
  license?: {
    node_id?: string;
    url?: string;
    spdx_id?: string;
    name?: string;
    key?: string;
  };
  code_of_conduct?: {
    html_url: string;
    body?: string;
    url: string;
    name: string;
    key: string;
  };
  /**
   * @format double
   */
  network_count?: number;
  /**
   * @format double
   */
  subscribers_count?: number;
  delete_branch_on_merge?: boolean;
  temp_clone_token?: string;
  role_name?: string;
  permissions?: {
    pull?: boolean;
    triage?: boolean;
    push?: boolean;
    maintain?: boolean;
    admin?: boolean;
  };
  updated_at?: string;
  created_at?: string;
  pushed_at?: string;
  visibility?: string;
  disabled?: boolean;
  archived?: boolean;
  has_discussions?: boolean;
  has_downloads?: boolean;
  has_pages?: boolean;
  has_wiki?: boolean;
  has_projects?: boolean;
  has_issues?: boolean;
  topics?: string[];
  is_template?: boolean;
  /**
   * @format double
   */
  open_issues_count?: number;
  default_branch?: string;
  /**
   * @format double
   */
  size?: number;
  /**
   * @format double
   */
  watchers_count?: number;
  /**
   * @format double
   */
  stargazers_count?: number;
  /**
   * @format double
   */
  forks_count?: number;
  language?: string;
  homepage?: string;
  svn_url?: string;
  hooks_url: string;
  mirror_url?: string;
  clone_url?: string;
  trees_url: string;
  teams_url: string;
  tags_url: string;
  subscription_url: string;
  subscribers_url: string;
  statuses_url: string;
  stargazers_url: string;
  ssh_url?: string;
  releases_url: string;
  pulls_url: string;
  notifications_url: string;
  milestones_url: string;
  merges_url: string;
  languages_url: string;
  labels_url: string;
  keys_url: string;
  issues_url: string;
  issue_events_url: string;
  issue_comment_url: string;
  git_url?: string;
  git_tags_url: string;
  git_refs_url: string;
  git_commits_url: string;
  forks_url: string;
  events_url: string;
  downloads_url: string;
  deployments_url: string;
  contributors_url: string;
  contents_url: string;
  compare_url: string;
  commits_url: string;
  comments_url: string;
  collaborators_url: string;
  branches_url: string;
  blobs_url: string;
  assignees_url: string;
  archive_url: string;
  url: string;
  fork: boolean;
  description: string;
  html_url: string;
  private: boolean;
  owner: {
    user_view_type?: string;
    starred_at?: string;
    site_admin: boolean;
    type: string;
    received_events_url: string;
    events_url: string;
    repos_url: string;
    organizations_url: string;
    subscriptions_url: string;
    starred_url: string;
    gists_url: string;
    following_url: string;
    followers_url: string;
    html_url: string;
    url: string;
    gravatar_id: string;
    avatar_url: string;
    node_id: string;
    /**
     * @format double
     */
    id: number;
    login: string;
    email?: string;
    name?: string;
  };
  full_name: string;
  name: string;
  node_id: string;
  /**
   * @format double
   */
  id: number;
}[];

export type GetTemplateReposVariables = {
  pathParams: GetTemplateReposPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchGetTemplateRepos = (variables: GetTemplateReposVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    GetTemplateReposResponse,
    GetTemplateReposError,
    undefined,
    {},
    {},
    GetTemplateReposPathParams
  >({ url: '/api/instructor/{courseId}/template-repos', method: 'get', ...variables, signal });

export const useGetTemplateRepos = <TData = GetTemplateReposResponse,>(
  variables: GetTemplateReposVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetTemplateReposResponse, GetTemplateReposError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<GetTemplateReposResponse, GetTemplateReposError, TData>({
    queryKey: queryKeyFn({
      path: '/api/instructor/{courseId}/template-repos',
      operationId: 'getTemplateRepos',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetTemplateRepos({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetReposPathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type GetReposError = Fetcher.ErrorWrapper<undefined>;

export type GetReposResponse = {
  security_and_analysis?: {
    secret_scanning_ai_detection?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning_non_provider_patterns?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning_push_protection?: {
      status?: 'enabled' | 'disabled';
    };
    secret_scanning?: {
      status?: 'enabled' | 'disabled';
    };
    dependabot_security_updates?: {
      status?: 'enabled' | 'disabled';
    };
    advanced_security?: {
      status?: 'enabled' | 'disabled';
    };
  };
  web_commit_signoff_required?: boolean;
  allow_forking?: boolean;
  /**
   * @format double
   */
  watchers?: number;
  /**
   * @format double
   */
  open_issues?: number;
  /**
   * @format double
   */
  forks?: number;
  license?: {
    node_id?: string;
    url?: string;
    spdx_id?: string;
    name?: string;
    key?: string;
  };
  code_of_conduct?: {
    html_url: string;
    body?: string;
    url: string;
    name: string;
    key: string;
  };
  /**
   * @format double
   */
  network_count?: number;
  /**
   * @format double
   */
  subscribers_count?: number;
  delete_branch_on_merge?: boolean;
  temp_clone_token?: string;
  role_name?: string;
  permissions?: {
    pull?: boolean;
    triage?: boolean;
    push?: boolean;
    maintain?: boolean;
    admin?: boolean;
  };
  updated_at?: string;
  created_at?: string;
  pushed_at?: string;
  visibility?: string;
  disabled?: boolean;
  archived?: boolean;
  has_discussions?: boolean;
  has_downloads?: boolean;
  has_pages?: boolean;
  has_wiki?: boolean;
  has_projects?: boolean;
  has_issues?: boolean;
  topics?: string[];
  is_template?: boolean;
  /**
   * @format double
   */
  open_issues_count?: number;
  default_branch?: string;
  /**
   * @format double
   */
  size?: number;
  /**
   * @format double
   */
  watchers_count?: number;
  /**
   * @format double
   */
  stargazers_count?: number;
  /**
   * @format double
   */
  forks_count?: number;
  language?: string;
  homepage?: string;
  svn_url?: string;
  hooks_url: string;
  mirror_url?: string;
  clone_url?: string;
  trees_url: string;
  teams_url: string;
  tags_url: string;
  subscription_url: string;
  subscribers_url: string;
  statuses_url: string;
  stargazers_url: string;
  ssh_url?: string;
  releases_url: string;
  pulls_url: string;
  notifications_url: string;
  milestones_url: string;
  merges_url: string;
  languages_url: string;
  labels_url: string;
  keys_url: string;
  issues_url: string;
  issue_events_url: string;
  issue_comment_url: string;
  git_url?: string;
  git_tags_url: string;
  git_refs_url: string;
  git_commits_url: string;
  forks_url: string;
  events_url: string;
  downloads_url: string;
  deployments_url: string;
  contributors_url: string;
  contents_url: string;
  compare_url: string;
  commits_url: string;
  comments_url: string;
  collaborators_url: string;
  branches_url: string;
  blobs_url: string;
  assignees_url: string;
  archive_url: string;
  url: string;
  fork: boolean;
  description: string;
  html_url: string;
  private: boolean;
  owner: {
    user_view_type?: string;
    starred_at?: string;
    site_admin: boolean;
    type: string;
    received_events_url: string;
    events_url: string;
    repos_url: string;
    organizations_url: string;
    subscriptions_url: string;
    starred_url: string;
    gists_url: string;
    following_url: string;
    followers_url: string;
    html_url: string;
    url: string;
    gravatar_id: string;
    avatar_url: string;
    node_id: string;
    /**
     * @format double
     */
    id: number;
    login: string;
    email?: string;
    name?: string;
  };
  full_name: string;
  name: string;
  node_id: string;
  /**
   * @format double
   */
  id: number;
}[];

export type GetReposVariables = {
  pathParams: GetReposPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchGetRepos = (variables: GetReposVariables, signal?: AbortSignal) =>
  pawtograderFetch<GetReposResponse, GetReposError, undefined, {}, {}, GetReposPathParams>({
    url: '/api/instructor/{courseId}/repos',
    method: 'get',
    ...variables,
    signal,
  });

export const useGetRepos = <TData = GetReposResponse,>(
  variables: GetReposVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetReposResponse, GetReposError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<GetReposResponse, GetReposError, TData>({
    queryKey: queryKeyFn({
      path: '/api/instructor/{courseId}/repos',
      operationId: 'getRepos',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetRepos({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListFilesInRepoPathParams = {
  /**
   * @format double
   */
  courseId: number;
  orgName: string;
  repoName: string;
};

export type ListFilesInRepoError = Fetcher.ErrorWrapper<undefined>;

export type ListFilesInRepoResponse = Schemas.FileListing[];

export type ListFilesInRepoVariables = {
  pathParams: ListFilesInRepoPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchListFilesInRepo = (variables: ListFilesInRepoVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    ListFilesInRepoResponse,
    ListFilesInRepoError,
    undefined,
    {},
    {},
    ListFilesInRepoPathParams
  >({
    url: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files',
    method: 'get',
    ...variables,
    signal,
  });

export const useListFilesInRepo = <TData = ListFilesInRepoResponse,>(
  variables: ListFilesInRepoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListFilesInRepoResponse, ListFilesInRepoError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<ListFilesInRepoResponse, ListFilesInRepoError, TData>({
    queryKey: queryKeyFn({
      path: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files',
      operationId: 'listFilesInRepo',
      variables,
    }),
    queryFn: ({ signal }) => fetchListFilesInRepo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetFileFromRepoPathParams = {
  /**
   * @format double
   */
  courseId: number;
  orgName: string;
  repoName: string;
  path: string;
};

export type GetFileFromRepoError = Fetcher.ErrorWrapper<undefined>;

export type GetFileFromRepoVariables = {
  pathParams: GetFileFromRepoPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchGetFileFromRepo = (variables: GetFileFromRepoVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content?: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        type: 'dir' | 'file' | 'submodule' | 'symlink';
      }[]
    | {
        submodule_git_url?: string;
        target?: string;
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        encoding: string;
        type: 'file';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        target: string;
        type: 'symlink';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        submodule_git_url: string;
        type: 'submodule';
      },
    GetFileFromRepoError,
    undefined,
    {},
    {},
    GetFileFromRepoPathParams
  >({
    url: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files/{path}',
    method: 'get',
    ...variables,
    signal,
  });

export const useGetFileFromRepo = <
  TData =
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content?: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        type: 'dir' | 'file' | 'submodule' | 'symlink';
      }[]
    | {
        submodule_git_url?: string;
        target?: string;
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        encoding: string;
        type: 'file';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        target: string;
        type: 'symlink';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        submodule_git_url: string;
        type: 'submodule';
      },
>(
  variables: GetFileFromRepoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      | {
          _links: {
            self: string;
            html: string;
            git: string;
          };
          download_url: string;
          html_url: string;
          git_url: string;
          url: string;
          sha: string;
          content?: string;
          path: string;
          name: string;
          /**
           * @format double
           */
          size: number;
          type: 'dir' | 'file' | 'submodule' | 'symlink';
        }[]
      | {
          submodule_git_url?: string;
          target?: string;
          _links: {
            self: string;
            html: string;
            git: string;
          };
          download_url: string;
          html_url: string;
          git_url: string;
          url: string;
          sha: string;
          content: string;
          path: string;
          name: string;
          /**
           * @format double
           */
          size: number;
          encoding: string;
          type: 'file';
        }
      | {
          _links: {
            self: string;
            html: string;
            git: string;
          };
          download_url: string;
          html_url: string;
          git_url: string;
          url: string;
          sha: string;
          path: string;
          name: string;
          /**
           * @format double
           */
          size: number;
          target: string;
          type: 'symlink';
        }
      | {
          _links: {
            self: string;
            html: string;
            git: string;
          };
          download_url: string;
          html_url: string;
          git_url: string;
          url: string;
          sha: string;
          path: string;
          name: string;
          /**
           * @format double
           */
          size: number;
          submodule_git_url: string;
          type: 'submodule';
        },
      GetFileFromRepoError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content?: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        type: 'dir' | 'file' | 'submodule' | 'symlink';
      }[]
    | {
        submodule_git_url?: string;
        target?: string;
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        content: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        encoding: string;
        type: 'file';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        target: string;
        type: 'symlink';
      }
    | {
        _links: {
          self: string;
          html: string;
          git: string;
        };
        download_url: string;
        html_url: string;
        git_url: string;
        url: string;
        sha: string;
        path: string;
        name: string;
        /**
         * @format double
         */
        size: number;
        submodule_git_url: string;
        type: 'submodule';
      },
    GetFileFromRepoError,
    TData
  >({
    queryKey: queryKeyFn({
      path: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files/{path}',
      operationId: 'getFileFromRepo',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetFileFromRepo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type TestSolutionWorkflowPathParams = {
  /**
   * @format double
   */
  courseId: number;
  /**
   * @format double
   */
  assignmentId: number;
  studentId: string;
};

export type TestSolutionWorkflowError = Fetcher.ErrorWrapper<undefined>;

export type TestSolutionWorkflowVariables = {
  pathParams: TestSolutionWorkflowPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchTestSolutionWorkflow = (
  variables: TestSolutionWorkflowVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    undefined,
    TestSolutionWorkflowError,
    undefined,
    {},
    {},
    TestSolutionWorkflowPathParams
  >({
    url: '/api/instructor/{courseId}/autograder/{assignmentId}/{studentId}',
    method: 'post',
    ...variables,
    signal,
  });

export const useTestSolutionWorkflow = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      TestSolutionWorkflowError,
      TestSolutionWorkflowVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    undefined,
    TestSolutionWorkflowError,
    TestSolutionWorkflowVariables
  >({
    mutationFn: (variables: TestSolutionWorkflowVariables) =>
      fetchTestSolutionWorkflow({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type CreateCourseForCanvasCoursePathParams = {
  /**
   * @format double
   */
  courseId: number;
};

export type CreateCourseForCanvasCourseError = Fetcher.ErrorWrapper<undefined>;

export type CreateCourseForCanvasCourseVariables = {
  pathParams: CreateCourseForCanvasCoursePathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchCreateCourseForCanvasCourse = (
  variables: CreateCourseForCanvasCourseVariables,
  signal?: AbortSignal,
) =>
  pawtograderFetch<
    undefined,
    CreateCourseForCanvasCourseError,
    undefined,
    {},
    {},
    CreateCourseForCanvasCoursePathParams
  >({ url: '/api/admin/course/{courseId}', method: 'post', ...variables, signal });

export const useCreateCourseForCanvasCourse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      CreateCourseForCanvasCourseError,
      CreateCourseForCanvasCourseVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = usePawtograderContext();
  return reactQuery.useMutation<
    undefined,
    CreateCourseForCanvasCourseError,
    CreateCourseForCanvasCourseVariables
  >({
    mutationFn: (variables: CreateCourseForCanvasCourseVariables) =>
      fetchCreateCourseForCanvasCourse({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetMeetingPathParams = {
  /**
   * @format double
   */
  requestId: number;
};

export type GetMeetingError = Fetcher.ErrorWrapper<undefined>;

export type GetMeetingVariables = {
  pathParams: GetMeetingPathParams;
} & PawtograderContext['fetcherOptions'];

export const fetchGetMeeting = (variables: GetMeetingVariables, signal?: AbortSignal) =>
  pawtograderFetch<
    Schemas.JoinMeetingResponse,
    GetMeetingError,
    undefined,
    {},
    {},
    GetMeetingPathParams
  >({ url: '/api/help-queue/help-request/{requestId}', method: 'get', ...variables, signal });

export const useGetMeeting = <TData = Schemas.JoinMeetingResponse,>(
  variables: GetMeetingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.JoinMeetingResponse, GetMeetingError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = usePawtograderContext(options);
  return reactQuery.useQuery<Schemas.JoinMeetingResponse, GetMeetingError, TData>({
    queryKey: queryKeyFn({
      path: '/api/help-queue/help-request/{requestId}',
      operationId: 'getMeeting',
      variables,
    }),
    queryFn: ({ signal }) => fetchGetMeeting({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: '/api/autograder/regression-tests';
      operationId: 'retrieveAutograderRegressionTests';
      variables: RetrieveAutograderRegressionTestsVariables;
    }
  | {
      path: '/api/admin/canvas/courses';
      operationId: 'getCanvasCourses';
      variables: GetCanvasCoursesVariables;
    }
  | {
      path: '/api/admin/canvas/courses/{courseId}';
      operationId: 'getCanvasCourse';
      variables: GetCanvasCourseVariables;
    }
  | {
      path: '/api/instructor/{courseId}/template-repos';
      operationId: 'getTemplateRepos';
      variables: GetTemplateReposVariables;
    }
  | {
      path: '/api/instructor/{courseId}/repos';
      operationId: 'getRepos';
      variables: GetReposVariables;
    }
  | {
      path: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files';
      operationId: 'listFilesInRepo';
      variables: ListFilesInRepoVariables;
    }
  | {
      path: '/api/instructor/{courseId}/repos/{orgName}/{repoName}/files/{path}';
      operationId: 'getFileFromRepo';
      variables: GetFileFromRepoVariables;
    }
  | {
      path: '/api/help-queue/help-request/{requestId}';
      operationId: 'getMeeting';
      variables: GetMeetingVariables;
    };
